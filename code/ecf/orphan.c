#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
/*
1. 发生了什么？（孤儿进程的收养）
当你的代码执行到 exit(0) 退出父进程时，而子进程还在 while(1) 循环里：

状态转变： 子进程立即成为孤儿进程。

自动收养： 内核会自动将这个子进程的父进程设置为 init 进程（在现代 Linux 系统中，通常是 systemd，其 PID 为 1）。

生命延续： 子进程并不会因为父进程的死而死，它会继续在后台运行，执行它的死循环。
2. 实验现象：你可以亲自观察
如果你编译运行这段代码，你会发现以下现象：

终端表现： 运行 1 秒后，父进程退出，你会看到终端提示符重新出现（比如 $），你可以输入新命令了。

后台占用： 虽然提示符回来了，但你的子进程还在跑。如果你打开任务管理器（输入 top 或 ps -ef），你会发现一个 CPU 占用率接近 100% 的进程（因为 while(1) 没有任何休眠）。

PPID 变化： * 在父进程结束前，子进程的 PPID（父进程 ID）是原来的父进程。

在父进程结束后，子进程的 PPID 会变成 1。

3. 这会带来什么问题？
资源浪费： 因为你的子进程里是 while(1) ;，它会持续消耗一个 CPU 核心的计算资源。

清理麻烦： 由于父进程已经不在了，它没法通过 wait() 来回收子进程。虽然 init 进程最终会负责清理子进程结束后的残留（僵尸状态），但在子进程主动退出前，它会一直存在。

4. 如何“杀掉”这个孤儿？
由于你现在失去了对该进程的直接控制（父进程已退），你需要在终端使用我们之前聊过的 kill 命令：

找到它的 PID： ps -aux | grep 你的程序名

强制杀死： kill -9 <PID>

5. 补充：为什么代码里要写 sleep(1)？
这段代码中的 sleep(1) 是为了确保子进程有足够的时间先跑起来并打印出 "hello,nice to meet you!"。

如果没有这 1 秒，父进程可能瞬间就 exit 了，根据 CPU 调度的随机性，子进程可能还没来得及打印，就被收养或者因为某些终端关联原因直接中断了输出。
*/
int main()
{
    if (!fork())
    {
        printf("hello,nice to meet you!\n");
        while (1)
            ;
    }
    sleep(1);
    exit(0);
}
